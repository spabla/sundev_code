Improvements for a system translating significant quantities of morse code data to text

Consideration to scalability issues has already been given in the design of the solution.  For example the designed solution is implemented as follows:

The file is read one line at a time.  The line is encoded or decoded and written to the output file prior to another line being read.  It would have been possible to read the entire file into a buffer in one go, however this was considered bad design because large files could have caused memory issues on systems with limited stack space.

The solution does not use std::map for storing letters and their morse string equivalents.  Performing a lookup in a map would have been a simpler solution.  However a map is sorted alphabetically and this would have meant that full advantage of morse codes efficiency is not being taken.  In morse code the most frequently occurring letter has the simplest morse string (ie. Dot). It therefore makes sense to sort letters in order of frequency as any lookup will be more efficient.

The solution does not have a gui interface which requires a user to sit there selecting files to encode or decode.  The solution is designed for batch processing. An example batch file is provided.  Splitting the files needing to be encoded / decoded across a number of batch files would allow advantage to be taken of multiple cores available on modern PCs.

The solution uses the “Strategy” Design Pattern.  This design pattern encapsulates a family of algorithms and makes them interchangeable.  This was done with one eye on the fact that faster or better algorithms for doing the encode / decode may be needed in the future.  For example the designed solution consists of a FileEncodeDecode class which on construction is passed an EncodeDecodeAlgorithm.  This algorithm could be for converting morse to text and in future could be replaced with a faster algorithm for doing the same thing.  The design has encapsulated what might vary (the algorithm) from what is likely to stay the same (you will always need to open a file, read from it, modify the content, write out the modified content).  The FileEncodeDecode class is also programmed to target an interface (One which takes a string and returns a string), it is only aware of the abstact EncodeDecodeAlgorithm class and has no knowledge of the specific concrete class it has been passed for doing the encode / decode.  The class could be passed an algorithm for converting to Chinese and it would have no issues provided the class passed in conformed to the defined interface.

Going forwards if the solution did not provide the required performance then analysis could be done to find the bottlenecks in the code or identify code that is frequently being run.  Optimisation of the code could then focus on the areas which give the biggest benefit.

In addition to code optimisation, consideration may be given to how the input and output data is stored.  For example the space between dots and dashes of the same character could be removed, the space between characters and words could be reduced.  This would make the files smaller and quicker to parse and create.

	