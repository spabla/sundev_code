//============================================================================
// Name        : test_suite_morse_encode_decode.cpp
// Author      : Sundev Pabla
// Version     :
// Copyright   : 
// Description : This is a test harness for the purpose of testing the morse encode
//               and decode software.
//============================================================================

#include <iostream>
#include <sstream>
#include <fstream>
#include <string.h>
#include <stdio.h>
#include <algorithm>
#include "basic_types.h"
#include "text_to_morse_algorithm.h"
#include "morse_to_text_algorithm.h"
#include "file_encode_decode.h"


enum PassFail_t
{
	FAIL,
	PASS,
};

// Function Prototypes
PassFail_t Test1_ObjectCreation();

PassFail_t Test2_EncodeDecodeFile(std::string inFile,
								  std::string morseFile,
								  std::string outFile);
PassFail_t Test3_MorseStringCharacterDecode();

void PerformEncodeDecode(std::string inFile,
		  	  	  	  	 std::string morseFile,
		                 std::string outFile);

void PerformDecodeOfMorseFile();

static const Uint8_t NUMBER_OF_INPUT_FILES = 3;
static const std::string inFileArray[NUMBER_OF_INPUT_FILES] =
									 {
	"./TestFiles/testFileHelloWorld.txt",
	"./TestFiles/testFileNumbers.txt",
	"./TestFiles/testFileSymbols.txt"
									 };
static const std::string morseFileArray[NUMBER_OF_INPUT_FILES] =
									 {
	"./TestFiles/testFileHelloWorld.morse",
	"./TestFiles/testFileNumbers.morse",
	"./TestFiles/testFileSymbols.morse"
									 };
static const std::string outFileArray[NUMBER_OF_INPUT_FILES] =
									 {
	"./TestFiles/testFileHelloWorldReverse.txt",
	"./TestFiles/testFileNumbersReverse.txt",
	"./TestFiles/testFileSymbolsReverse.txt"
									 };

int main()
{
	int testPassCount = 0;
	int testFailCount = 0;

	// Run tests

	// Test Case 1
	Test1_ObjectCreation() == PASS ? testPassCount++:testFailCount++;

	// Test Case 2 (Consists of multiple test)
	for (Uint8_t i = 0; i < NUMBER_OF_INPUT_FILES; i++)
	{
		Test2_EncodeDecodeFile(inFileArray[i],
				               morseFileArray[i],
							   outFileArray[i]) == PASS ? testPassCount++:testFailCount++;
	}

	// Test Case 3
	Test3_MorseStringCharacterDecode() == PASS ? testPassCount++:testFailCount++;

	std::cout <<"Tests Passed: " << testPassCount << std::endl;
	std::cout <<"Tests Failed: " << testFailCount << std::endl;

	std::cout <<"Press any key to exit" << std::endl;

	std::cin.get();

	return 0;
}

PassFail_t Test1_ObjectCreation()
{
	// This function confirms that even the passing of nonsensical paths does not cause crash
	EncodeDecodeAlgorithms::TextToMorseAlgorithm theEncodeAlgorithm;
	EncodeDecodeAlgorithms::MorseToTextAlgorithm theDecodeAlgorithm;

	FileEncodeDecode theFileEncode(theEncodeAlgorithm,"./TestFiles/anyString","./TestFiles/anyString");
	FileEncodeDecode theFileDecode(theDecodeAlgorithm,"./TestFiles/anyString","./TestFiles/anyString");

	std::cout << "Note: Could not open input file being written to console is expected result for test being perfomred" << std::endl;

	return PASS;
}

PassFail_t Test2_EncodeDecodeFile(std::string inFile,
		  std::string morseFile,
		  std::string outFile)
{
	// Initialise to Fail
	PassFail_t theResult = FAIL;

	PerformEncodeDecode(inFile,morseFile,outFile);

	// Now confirm successful encode decode
	std::ifstream theInputFile(inFile.c_str());
	std::ifstream theOutputFile(outFile.c_str());

	std::string lineIn;
	std::string lineOut;

	std::getline(theInputFile, lineIn);
	std::getline(theOutputFile, lineOut);

	std::transform(lineIn.begin(), lineIn.end(),lineIn.begin(), ::toupper);

	if (lineIn.compare(lineOut) == 0)
	{
		theResult = PASS;
	}

	theInputFile.close();
	theOutputFile.close();

	return theResult;
}

void PerformEncodeDecode(std::string inFile,
		  	  	  	  	 std::string morseFile,
		                 std::string outFile)
{
	EncodeDecodeAlgorithms::TextToMorseAlgorithm theEncodeAlgorithm;
	EncodeDecodeAlgorithms::MorseToTextAlgorithm theDecodeAlgorithm;

	FileEncodeDecode theFileEncode(theEncodeAlgorithm,
								   inFile,
								   morseFile);
	theFileEncode.process();
	FileEncodeDecode theFileDecode(theDecodeAlgorithm,
								   morseFile,
								   outFile);
	theFileDecode.process();
}

PassFail_t Test3_MorseStringCharacterDecode()
{
	// Previous tests are a bit incestuous in that they decode files encoded
	// by the program under test.  This test decodes a morse file not generated by
	// the program under test, thereby proving that the encoding is correct.

	// This test also proves the requirement that the morse to text program
	// should be able to handle morse files which do not have a space between
	// dots and dashes of the same chararter.
	PerformDecodeOfMorseFile();

	// The output of the above test has been manually confirmed.  By putting the
	// output file of the above test through test 2 we confirm that the morse we
	// generate must be equivalen to the independent morse file
	return Test2_EncodeDecodeFile("./TestFiles/morse_character_string_decoded.txt",
						          "./TestFiles/morse_character_string_decoded.morse",
								  "./TestFiles/morse_character_string_decoded_reverse.txt");
}

void PerformDecodeOfMorseFile()
{
	EncodeDecodeAlgorithms::MorseToTextAlgorithm theDecodeAlgorithm;
	FileEncodeDecode theFileDecode(theDecodeAlgorithm,
			                       "./TestFiles/morse_character_string_input.txt",
								   "./TestFiles/morse_character_string_decoded.txt");
	theFileDecode.process();
}
